/**
 * @file Firebase Security Rules for FlowIDQ
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for personal data,
 * with public read access where explicitly required.  Data validation is relaxed to
 * facilitate rapid prototyping, focusing on authorization and relational integrity.
 *
 * @data_structure
 * - /users/{userId}: User profile information, owned by the user.
 * - /users/{userId}/documents/{documentId}: Documents owned by a specific user.
 * - /qrCodes/{qrCodeId}: QR code information. Top-level collection for public lookup.
 * - /locations/{locationId}: Information about physical locations (e.g., hospitals).
 * - /locations/{locationId}/queues/{queueId}: Queues at a specific location.
 * - /users/{userId}/queueTokens/{queueTokenId}: Queue tokens assigned to a user.
 * - /accessHistory/{accessHistoryId}: Access history entries for documents.
 *
 * @key_security_decisions
 * - User data is private and accessible only to the owning user.
 * - Public read access is enabled for locations and queues.
 * - QR code access is protected with OTP and password mechanisms (implementation TBD).
 * - Listing user-owned subcollections is allowed only for the owner.
 * - The rules do not implement any user roles (e.g., admin).
 *
 * @denormalization_for_authorization
 * - User ownership is enforced through path-based rules (e.g., /users/{userId}/...).
 * - The `userId` field is included in `Document` and `QueueToken` entities to enable
 *   data integrity checks and prevent unauthorized modification of relationships.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces access control for user profiles. Only the user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their own profile.
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes their own profile.
     * @deny (create) User with ID 'user123' attempts to create a profile for 'user456'.
     * @deny (get, update, delete) User with ID 'user123' attempts to read/update/delete the profile of 'user456'.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // Listing all users is not permitted.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.id == userId; // Enforce immutability of userId.
      allow delete: if isSignedIn() && isOwner(userId) && resource != null;
    }

    /**
     * @description Enforces access control for documents. Only the owner user can read/write their own documents.
     * @path /users/{userId}/documents/{documentId}
     * @allow (create) User with ID 'user123' creates a document in their documents collection.
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes a document in their documents collection.
     * @deny (create) User with ID 'user123' attempts to create a document for 'user456'.
     * @deny (get, update, delete) User with ID 'user123' attempts to read/update/delete a document in the documents collection of 'user456'.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/documents/{documentId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.userId == userId && resource != null; //Enforce userId immutability
      allow delete: if isSignedIn() && isOwner(userId) && resource != null;
    }

    /**
     * @description Enforces access control for QR codes.
     * @path /qrCodes/{qrCodeId}
     * @allow (get) Any user can attempt to get a QR code.
     * @allow (create, update, delete) No one can create, update, or delete a QR code.
     * @deny (list) No one can list QR codes.
     * @principle Complex access rules are required to validate document ownership and OTP/Password combinations.
     */
    match /qrCodes/{qrCodeId} {
      allow get: if true; // Allow get for all users. More specific access control to be implemented using OTP and access password

      // CRITICAL: Cannot implement owner-only writes.  Need to implement custom logic to validate
      // document ownership, OTP, and access password.
      allow create, update, delete: if false; // TODO: Add owner validation and OTP/password checks
      allow list: if false;
    }

    /**
     * @description Allows public read access to location information.
     * @path /locations/{locationId}
     * @allow (get, list) Any user can read location information.
     * @deny (create, update, delete) No one can create, update, or delete location information.
     * @principle Public read access.
     */
    match /locations/{locationId} {
      allow get, list: if true; // Public read access for locations
      allow create, update, delete: if false; // No one can modify locations.
    }

    /**
     * @description Allows public read access to queue information.  Write access is denied.
     * @path /locations/{locationId}/queues/{queueId}
     * @allow (get, list) Any user can read queue information for any location.
     * @deny (create, update, delete) No one can create, update, or delete queue information.
     * @principle Public read access, no write access.
     */
    match /locations/{locationId}/queues/{queueId} {
      allow get, list: if true; // Public read access for queues
      allow create, update, delete: if false; // No one can modify queues
    }

    /**
     * @description Enforces access control for queue tokens. Only the owner user can read/write their own queue tokens.
     * @path /users/{userId}/queueTokens/{queueTokenId}
     * @allow (create) User with ID 'user123' creates a queue token in their queue tokens collection.
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes a queue token in their queue tokens collection.
     * @deny (create) User with ID 'user123' attempts to create a queue token for 'user456'.
     * @deny (get, update, delete) User with ID 'user123' attempts to read/update/delete a queue token in the queue tokens collection of 'user456'.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/queueTokens/{queueTokenId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.userId == userId && resource != null; //Enforce userId immutability.
      allow delete: if isSignedIn() && isOwner(userId) && resource != null;
    }

    /**
     * @description Enforces access control for access history. Anyone can create, but nobody can list, update, or delete.
     * @path /accessHistory/{accessHistoryId}
     * @allow (create) Any signed in user can create an access history entry.
     * @deny (get, list, update, delete) No one can get, list, update, or delete access history entries.
     * @principle Allows creation for tracking, restricts modification.
     */
    match /accessHistory/{accessHistoryId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn(); // Anyone can create an access history entry.
      allow update: if false;
      allow delete: if false;
    }
  }
}